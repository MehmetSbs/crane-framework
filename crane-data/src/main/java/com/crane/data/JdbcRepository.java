package com.crane.data;

import com.crane.core.ConnectionHolder;
import com.crane.data.annotation.AutoGenerated;
import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

public abstract class JdbcRepository<T, ID> {

  protected final EntityMeta<T> meta;

  public JdbcRepository(Class<T> entityClass) {
    this.meta = EntityParser.parse(entityClass);
  }

  protected Connection getConnection() {
    return ConnectionHolder.get();
  }

  public Optional<T> findById(ID id) throws SQLException {
    String sql = "SELECT * FROM " + meta.table() + " WHERE " + meta.idField() + " = ?";
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {
      stmt.setObject(1, id);
      ResultSet rs = stmt.executeQuery();
      if (rs.next()) {
        return Optional.of(mapRow(rs));
      }
    }
    return Optional.empty();
  }

  public List<T> findAll() throws SQLException {
    String sql = "SELECT * FROM " + meta.table();
    List<T> result = new ArrayList<>();
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql);
        ResultSet rs = stmt.executeQuery()) {
      while (rs.next()) {
        result.add(mapRow(rs));
      }
    }
    return result;
  }

  public T save(T entity) throws SQLException {
    if (isNew(entity)) {
      return insert(entity);
    } else {
      return update(entity);
    }
  }

  // Update the isNew method to handle different auto-generation strategies
  private boolean isNew(T entity) throws SQLException {
    try {
      Field idField = meta.getField(meta.idField());
      idField.setAccessible(true);
      Object idValue = idField.get(entity);

      // If ID is auto-generated and null, it's definitely new
      if (meta.isIdAutoGenerated() && idValue == null) {
        return true;
      }

      // If ID is not auto-generated and null, throw exception
      if (!meta.isIdAutoGenerated() && idValue == null) {
        throw new IllegalArgumentException("Non-auto-generated ID cannot be null");
      }

      // If ID has a value, check if it exists in database
      if (idValue != null) {
        return !existsById(idValue);
      }

      return true;
    } catch (IllegalAccessException e) {
      throw new RuntimeException("Failed to access ID field", e);
    }
  }

  private T mapRow(ResultSet rs) throws SQLException {
    try {
      T instance = meta.type().getDeclaredConstructor().newInstance();
      for (String column : meta.columns()) {
        Field field = meta.getField(column);
        field.setAccessible(true);

        Object value = rs.getObject(column);
        if (value != null) {
          // Add type conversion logic here
          value = SqlUtil.convertType(value, field.getType());
        }
        field.set(instance, value);
      }
      return instance;
    } catch (Exception e) {
      throw new RuntimeException("Failed to map row to entity", e);
    }
  }

  public boolean existsById(Object id) throws SQLException {
    String sql = "SELECT 1 FROM " + meta.table() + " WHERE " + meta.idField() + " = ?";
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {
      stmt.setObject(1, id);
      try (ResultSet rs = stmt.executeQuery()) {
        return rs.next();
      }
    }
  }

  // Updated insert method
  private T insert(T entity) throws SQLException {
    // STEP 1: Generate application-side values BEFORE building INSERT
    generateApplicationValues(entity);

    // STEP 2: Filter out only DATABASE-generated fields from insert
    List<String> columns = meta.columns().stream()
        .filter(col -> !meta.isDatabaseGenerated(col)) // Only exclude DB-generated
        .collect(Collectors.toList());

    if (columns.isEmpty()) {
      throw new SQLException("No insertable columns found. All fields are database-generated.");
    }

    String columnNames = String.join(", ", columns);
    String placeholders = columns.stream().map(c -> "?").collect(Collectors.joining(", "));
    String sql =
        "INSERT INTO " + meta.table() + " (" + columnNames + ") VALUES (" + placeholders + ")";

    // STEP 3: Determine if we need generated keys (only for DB-generated fields)
    boolean needsGeneratedKeys = !meta.getDatabaseGeneratedFields().isEmpty();

    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql,
            needsGeneratedKeys ? Statement.RETURN_GENERATED_KEYS : Statement.NO_GENERATED_KEYS)) {

      setParameters(stmt, entity, columns);

      int affectedRows = stmt.executeUpdate();
      if (affectedRows == 0) {
        throw new SQLException("Insert failed, no rows affected.");
      }

      // STEP 4: Handle only database-generated values
      if (needsGeneratedKeys) {
        handleDatabaseGeneratedKeys(stmt, entity);
      }

      return entity;

    } catch (IllegalAccessException e) {
      throw new RuntimeException("Failed to access field during insert", e);
    }
  }

  // NEW METHOD: Generate application-side values before insert
  private void generateApplicationValues(T entity) throws SQLException {
    try {
      for (String fieldName : meta.getApplicationGeneratedFields()) {
        Field field = meta.getField(fieldName);
        field.setAccessible(true);

        // Only generate if field is currently null
        if (field.get(entity) == null) {
          AutoGenerated annotation = field.getAnnotation(AutoGenerated.class);
          Object generatedValue = generateApplicationValue(field, annotation);
          if (generatedValue != null) {
            field.set(entity, generatedValue);
          }
        }
      }
    } catch (IllegalAccessException e) {
      throw new RuntimeException("Failed to generate application values", e);
    }
  }

  // NEW METHOD: Generate application values (like UUID)
  private Object generateApplicationValue(Field field, AutoGenerated annotation) {
    AutoGenerated.Strategy strategy = annotation.strategy();

    switch (strategy) {
      case UUID:
        if (field.getType() == UUID.class) {
          return UUID.randomUUID();
        } else if (field.getType() == String.class) {
          return UUID.randomUUID().toString();
        }
        throw new RuntimeException("UUID strategy can only be used with UUID or String fields");

        // Add other application-generated strategies here

      default:
        throw new RuntimeException("Unsupported application generation strategy: " + strategy);
    }
  }

  private void handleDatabaseGeneratedKeys(PreparedStatement stmt, T entity)
      throws SQLException, IllegalAccessException {
    try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
      if (generatedKeys.next()) {
        // Handle only database-generated fields
        for (String autoGenField : meta.getDatabaseGeneratedFields()) {
          Field field = meta.getField(autoGenField);
          field.setAccessible(true);

          AutoGenerated autoGenAnnotation = field.getAnnotation(AutoGenerated.class);
          if (autoGenAnnotation != null) {
            Object generatedValue = generateDatabaseValue(generatedKeys, field, autoGenAnnotation);
            if (generatedValue != null) {
              field.set(entity, generatedValue);
            }
          }
        }
      }
    }
  }

  // UPDATED METHOD: Generate only database values
  private Object generateDatabaseValue(ResultSet generatedKeys, Field field,
      AutoGenerated autoGenAnnotation) throws SQLException {

    AutoGenerated.Strategy strategy = autoGenAnnotation.strategy();

    switch (strategy) {
      case DATABASE:
        Object dbValue;
        try {
          dbValue = generatedKeys.getObject(field.getName());
        } catch (SQLException e) {
          // Fallback to index if column name doesn't work
          dbValue = generatedKeys.getObject(1);
        }
        return SqlUtil.convertType(dbValue, field.getType());

      default:
        throw new RuntimeException("Unsupported database generation strategy: " + strategy);
    }
  }

  private T update(T entity) throws SQLException {
    List<String> updateColumns = meta.columns().stream()
        .filter(col -> !col.equals(meta.idField()))
        .collect(Collectors.toList());

    if (updateColumns.isEmpty()) {
      return entity; // Nothing to update, return original entity
    }

    String setClause = updateColumns.stream()
        .map(col -> col + " = ?")
        .collect(Collectors.joining(", "));

    String sql =
        "UPDATE " + meta.table() + " SET " + setClause + " WHERE " + meta.idField() + " = ?";

    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {

      // Set update parameters
      setParameters(stmt, entity, updateColumns);

      // Set WHERE clause parameter (ID)
      Field idField = meta.getField(meta.idField());
      idField.setAccessible(true);
      Object idValue = idField.get(entity);
      stmt.setObject(updateColumns.size() + 1, idValue);

      int affectedRows = stmt.executeUpdate();
      if (affectedRows == 0) {
        throw new SQLException("Update failed, no rows affected. Entity may not exist.");
      }

      // For update, we can either return the modified entity as-is,
      // or fetch it fresh from the database to get any database-level changes
      // (like triggers, computed columns, etc.)

      // Option 1: Return the entity as-is (faster)
      return entity;

      // Option 2: Fetch fresh from database (uncomment if you need DB-level changes)
      // return findById(idValue);

    } catch (IllegalAccessException e) {
      throw new RuntimeException("Failed to access field during update", e);
    }
  }

  private void setParameters(PreparedStatement stmt, T entity, List<String> columns)
      throws SQLException, IllegalAccessException {
    for (int i = 0; i < columns.size(); i++) {
      Field field = meta.getField(columns.get(i));
      field.setAccessible(true);
      Object value = field.get(entity);

      if (value != null) {
        stmt.setObject(i + 1, value);
      } else {
        // Handle null values properly based on field type
        stmt.setNull(i + 1, SqlUtil.getSqlType(field.getType()));
      }
    }
  }

  private boolean hasAutoGeneratedFields() {
    return !meta.getAutoGeneratedFields().isEmpty();
  }

  // Additional CRUD and batch operations

  public void deleteById(ID id) throws SQLException {
    String sql = "DELETE FROM " + meta.table() + " WHERE " + meta.idField() + " = ?";
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {
      stmt.setObject(1, id);
      int affectedRows = stmt.executeUpdate();
      if (affectedRows == 0) {
        throw new SQLException(
            "Delete failed, no rows affected. Entity with ID " + id + " may not exist.");
      }
    }
  }

  public int deleteByField(String fieldName, Object value) throws SQLException {
    validateFieldName(fieldName);
    String sql = "DELETE FROM " + meta.table() + " WHERE " + fieldName + " = ?";
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {
      stmt.setObject(1, value);
      return stmt.executeUpdate();
    }
  }

  public List<T> findByField(String fieldName, Object value) throws SQLException {
    validateFieldName(fieldName);
    String sql = "SELECT * FROM " + meta.table() + " WHERE " + fieldName + " = ?";
    List<T> result = new ArrayList<>();
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {
      stmt.setObject(1, value);
      try (ResultSet rs = stmt.executeQuery()) {
        while (rs.next()) {
          result.add(mapRow(rs));
        }
      }
    }
    return result;
  }

  public Optional<T> findOneByField(String fieldName, Object value) throws SQLException {
    validateFieldName(fieldName);
    String sql = "SELECT * FROM " + meta.table() + " WHERE " + fieldName + " = ? LIMIT 1";
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {
      stmt.setObject(1, value);
      try (ResultSet rs = stmt.executeQuery()) {
        if (rs.next()) {
          return Optional.of(mapRow(rs));
        }
      }
    }
    return Optional.empty();
  }

  // Batch operations
  public void saveAll(Collection<T> entities) throws SQLException {
    if (entities == null || entities.isEmpty()) {
      return;
    }

    // Separate new entities from existing ones
    List<T> newEntities = new ArrayList<>();
    List<T> existingEntities = new ArrayList<>();

    for (T entity : entities) {
      if (isNew(entity)) {
        newEntities.add(entity);
      } else {
        existingEntities.add(entity);
      }
    }

    // Batch insert new entities
    if (!newEntities.isEmpty()) {
      batchInsert(newEntities);
    }

    // Batch update existing entities
    if (!existingEntities.isEmpty()) {
      batchUpdate(existingEntities);
    }
  }

  private void batchInsert(List<T> entities) throws SQLException {
    if (entities.isEmpty()) {
      return;
    }

    // STEP 1: Generate application-side values for all entities BEFORE building INSERT
    for (T entity : entities) {
      generateApplicationValues(entity);
    }

    // STEP 2: Filter out only DATABASE-generated fields from batch insert
    List<String> columns = meta.columns().stream()
        .filter(col -> !meta.isDatabaseGenerated(col)) // Only exclude DB-generated
        .collect(Collectors.toList());

    if (columns.isEmpty()) {
      throw new SQLException("No insertable columns found. All fields are database-generated.");
    }

    String columnNames = String.join(", ", columns);
    String placeholders = columns.stream().map(c -> "?").collect(Collectors.joining(", "));
    String sql =
        "INSERT INTO " + meta.table() + " (" + columnNames + ") VALUES (" + placeholders + ")";

    // STEP 3: Determine if we need generated keys (only for DB-generated fields)
    boolean needsGeneratedKeys = !meta.getDatabaseGeneratedFields().isEmpty();

    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql,
            needsGeneratedKeys ? Statement.RETURN_GENERATED_KEYS : Statement.NO_GENERATED_KEYS)) {

      for (T entity : entities) {
        setParameters(stmt, entity, columns);
        stmt.addBatch();
      }

      int[] results = stmt.executeBatch();

      // STEP 4: Handle generated keys for batch operations (only DB-generated)
      if (needsGeneratedKeys) {
        handleBatchDatabaseGeneratedKeys(stmt, entities);
      }

      // Check for failed inserts
      for (int i = 0; i < results.length; i++) {
        if (results[i] == Statement.EXECUTE_FAILED) {
          throw new SQLException("Batch insert failed for entity at index " + i);
        }
      }
    } catch (IllegalAccessException e) {
      throw new RuntimeException("Failed to access field during batch insert", e);
    }
  }

  private void handleBatchDatabaseGeneratedKeys(PreparedStatement stmt, List<T> entities)
      throws SQLException, IllegalAccessException {

    try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
      int entityIndex = 0;
      while (generatedKeys.next() && entityIndex < entities.size()) {
        T entity = entities.get(entityIndex);

        // Handle only database-generated fields
        for (String autoGenField : meta.getDatabaseGeneratedFields()) {
          Field field = meta.getField(autoGenField);
          field.setAccessible(true);

          AutoGenerated autoGenAnnotation = field.getAnnotation(AutoGenerated.class);
          if (autoGenAnnotation != null) {
            Object generatedValue = generateDatabaseValue(generatedKeys, field, autoGenAnnotation);
            if (generatedValue != null) {
              field.set(entity, generatedValue);
            }
          }
        }
        entityIndex++;
      }
    }
  }

  private void batchUpdate(List<T> entities) throws SQLException {
    if (entities.isEmpty()) {
      return;
    }

    List<String> updateColumns = meta.columns().stream()
        .filter(col -> !col.equals(meta.idField()))
        .collect(Collectors.toList());

    if (updateColumns.isEmpty()) {
      return; // Nothing to update
    }

    String setClause = updateColumns.stream()
        .map(col -> col + " = ?")
        .collect(Collectors.joining(", "));

    String sql =
        "UPDATE " + meta.table() + " SET " + setClause + " WHERE " + meta.idField() + " = ?";

    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {

      for (T entity : entities) {
        // Set update parameters
        setParameters(stmt, entity, updateColumns);

        // Set WHERE clause parameter (ID)
        Field idField = meta.getField(meta.idField());
        idField.setAccessible(true);
        stmt.setObject(updateColumns.size() + 1, idField.get(entity));
        stmt.addBatch();
      }

      int[] results = stmt.executeBatch();

      // Check for failed updates
      for (int i = 0; i < results.length; i++) {
        if (results[i] == 0) {
          throw new SQLException(
              "Batch update failed for entity at index " + i + ". Entity may not exist.");
        }
      }
    } catch (IllegalAccessException e) {
      throw new RuntimeException("Failed to access field during batch update", e);
    }
  }

  public void deleteAll(Collection<ID> ids) throws SQLException {
    if (ids == null || ids.isEmpty()) {
      return;
    }

    String sql = "DELETE FROM " + meta.table() + " WHERE " + meta.idField() + " = ?";
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {

      for (ID id : ids) {
        stmt.setObject(1, id);
        stmt.addBatch();
      }

      int[] results = stmt.executeBatch();

      // Optionally check if all deletes were successful
      for (int i = 0; i < results.length; i++) {
        if (results[i] == 0) {
          // Log warning or handle as needed - entity might not exist
          System.err.println("Warning: No entity deleted for ID at index " + i);
        }
      }
    }
  }

  public List<T> findAllByIds(Collection<ID> ids) throws SQLException {
    if (ids == null || ids.isEmpty()) {
      return new ArrayList<>();
    }

    String placeholders = ids.stream().map(id -> "?").collect(Collectors.joining(", "));
    String sql =
        "SELECT * FROM " + meta.table() + " WHERE " + meta.idField() + " IN (" + placeholders + ")";

    List<T> result = new ArrayList<>();
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {

      int paramIndex = 1;
      for (ID id : ids) {
        stmt.setObject(paramIndex++, id);
      }

      try (ResultSet rs = stmt.executeQuery()) {
        while (rs.next()) {
          result.add(mapRow(rs));
        }
      }
    }
    return result;
  }

  // Advanced query methods with multiple conditions
  public List<T> findByFields(Map<String, Object> conditions) throws SQLException {
    if (conditions == null || conditions.isEmpty()) {
      return findAll();
    }

    // Validate all field names
    conditions.keySet().forEach(this::validateFieldName);

    String whereClause = conditions.keySet().stream()
        .map(field -> field + " = ?")
        .collect(Collectors.joining(" AND "));

    String sql = "SELECT * FROM " + meta.table() + " WHERE " + whereClause;

    List<T> result = new ArrayList<>();
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {

      int paramIndex = 1;
      for (Object value : conditions.values()) {
        stmt.setObject(paramIndex++, value);
      }

      try (ResultSet rs = stmt.executeQuery()) {
        while (rs.next()) {
          result.add(mapRow(rs));
        }
      }
    }
    return result;
  }

  public int deleteByFields(Map<String, Object> conditions) throws SQLException {
    if (conditions == null || conditions.isEmpty()) {
      throw new IllegalArgumentException(
          "Cannot delete all records without conditions. Use deleteAll() method explicitly if needed.");
    }

    // Validate all field names
    conditions.keySet().forEach(this::validateFieldName);

    String whereClause = conditions.keySet().stream()
        .map(field -> field + " = ?")
        .collect(Collectors.joining(" AND "));

    String sql = "DELETE FROM " + meta.table() + " WHERE " + whereClause;

    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {

      int paramIndex = 1;
      for (Object value : conditions.values()) {
        stmt.setObject(paramIndex++, value);
      }

      return stmt.executeUpdate();
    }
  }

  // Helper method to validate field names
  private void validateFieldName(String fieldName) {
    if (!meta.columns().contains(fieldName)) {
      throw new IllegalArgumentException(
          "Field '" + fieldName + "' does not exist in entity " + meta.type().getSimpleName());
    }
  }

  public Page<T> findAll(PageRequest pageRequest) throws SQLException {
    // First, get total count
    long totalElements = count();

    // Build paginated query
    StringBuilder sql = new StringBuilder("SELECT * FROM " + meta.table());

    if (pageRequest.getSortBy() != null) {
      validateFieldName(pageRequest.getSortBy());
      sql.append(" ORDER BY ").append(pageRequest.getSortBy());
      sql.append(pageRequest.isAscending() ? " ASC" : " DESC");
    }

    sql.append(" LIMIT ? OFFSET ?");

    List<T> content = new ArrayList<>();
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql.toString())) {

      stmt.setInt(1, pageRequest.getSize());
      stmt.setInt(2, pageRequest.getOffset());

      try (ResultSet rs = stmt.executeQuery()) {
        while (rs.next()) {
          content.add(mapRow(rs));
        }
      }
    }

    return new Page<>(content, pageRequest.getPage(), pageRequest.getSize(), totalElements);
  }

  public long count() throws SQLException {
    String sql = "SELECT COUNT(*) FROM " + meta.table();
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql);
        ResultSet rs = stmt.executeQuery()) {

      if (rs.next()) {
        return rs.getLong(1);
      }
      return 0;
    }
  }

  public long countByField(String fieldName, Object value) throws SQLException {
    validateFieldName(fieldName);
    String sql = "SELECT COUNT(*) FROM " + meta.table() + " WHERE " + fieldName + " = ?";
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {

      stmt.setObject(1, value);
      try (ResultSet rs = stmt.executeQuery()) {
        if (rs.next()) {
          return rs.getLong(1);
        }
        return 0;
      }
    }
  }

  /**
   * Entry point for custom queries with fluent API
   *
   * @return QueryBuilder instance for building custom queries
   */
  public QueryBuilder customQuery() {
    return new QueryBuilder(this);
  }

  /**
   * Execute a custom SELECT query with named parameters
   *
   * @param sql         SQL query with named parameters
   * @param namedParams Map of parameter names to values
   * @param resultType  Class to map results to
   * @return List of mapped objects
   * @throws SQLException if query execution fails
   */
  protected <T> List<T> executeCustomQuery(String sql, Map<String, Object> namedParams,
      Class<T> resultType) throws SQLException {
    QueryBuilder.ParsedQuery parsedQuery = QueryBuilder.parseNamedParameters(sql, namedParams);

    List<T> results = new ArrayList<>();
    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(parsedQuery.sql)) {

      // Set parameters
      SqlUtil.setParameters(stmt, parsedQuery.parameters);

      try (ResultSet rs = stmt.executeQuery()) {
        while (rs.next()) {
          T mappedObject = mapRowToType(rs, resultType);
          results.add(mappedObject);
        }
      }
    }
    return results;
  }

  /**
   * Execute a custom COUNT query with named parameters
   *
   * @param sql         SQL query with named parameters
   * @param namedParams Map of parameter names to values
   * @return Count result as Long
   * @throws SQLException if query execution fails
   */
  protected Long executeCountQuery(String sql, Map<String, Object> namedParams)
      throws SQLException {
    QueryBuilder.ParsedQuery parsedQuery = QueryBuilder.parseNamedParameters(sql, namedParams);

    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(parsedQuery.sql)) {

      SqlUtil.setParameters(stmt, parsedQuery.parameters);

      try (ResultSet rs = stmt.executeQuery()) {
        if (rs.next()) {
          return rs.getLong(1);
        }
        return 0L;
      }
    }
  }

  /**
   * Execute a custom UPDATE/DELETE query with named parameters
   *
   * @param sql         SQL query with named parameters
   * @param namedParams Map of parameter names to values
   * @return Number of affected rows
   * @throws SQLException if query execution fails
   */
  protected int executeUpdateQuery(String sql, Map<String, Object> namedParams)
      throws SQLException {
    QueryBuilder.ParsedQuery parsedQuery = QueryBuilder.parseNamedParameters(sql, namedParams);

    try (Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(parsedQuery.sql)) {

      SqlUtil.setParameters(stmt, parsedQuery.parameters);
      return stmt.executeUpdate();
    }
  }

  /**
   * Map a ResultSet row to a specific type (DTO or Entity)
   *
   * @param rs         ResultSet positioned at current row
   * @param resultType Target class for mapping
   * @return Mapped object instance
   * @throws SQLException if mapping fails
   */
  private <T> T mapRowToType(ResultSet rs, Class<T> resultType) throws SQLException {
    try {
      // Check if it's the same as our entity type, use existing mapping
      if (resultType.equals(meta.type())) {
        return (T) mapRow(rs);
      }

      // For DTOs, use reflection-based mapping
      return SqlUtil.mapRowToDto(rs, resultType);

    } catch (Exception e) {
      throw new SQLException("Failed to map row to type: " + resultType.getSimpleName(), e);
    }
  }


}
